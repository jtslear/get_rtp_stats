#!/usr/bin/ruby -w

require 'optparse'
require 'ostruct'
require 'net/ping'
require 'rubygems'
require 'snmp'

class GetTheOptions
  def self.parse(args)

    script_version = "0.01"
    options = OpenStruct.new
    options.device_list = []
    options.community = "public" # default to a common community string
    options.warning = "0"
    options.critical = "0"
    options.exit_status = "3"
    options.maximum = "0"
    options.verbose = false

    opts = OptionParser.new do |user_input|
      user_input.banner = "Usage: #{user_input.program_name} [options]"
      user_input.on("-d x y z", "--device x y z", Array, "Input list of devices seperated by a comma") do |device|
        options.device_list = device
      end
      user_input.on("-c N", "--critical N", "Specify crictal threshold") do |critical|
        options.critical = critical
      end
      user_input.on("-w N", "--warning N", "Specify warning threshold") do |warning|
        options.warning = warning
      end
      user_input.on("-m N", "--maximum N", "Specify max threshold") do |maximum|
        options.maximum = maximum
      end
      user_input.on("-C String", "--community String", String, "Specify snmp community") do |community|
        options.community = community
      end
      user_input.on("-V", "--verbose", "Run verbosely (debugging only)") do |verbose|
        options.verbose = verbose
      end
      user_input.on("-v", "--version", "Prints Version of this script.") do
        puts "get_rtp_stats #{script_version}"
        exit
      end
      user_input.on_tail("-h", "--help", "Show help message") do
        puts opts
        exit
      end
    end

    opts.parse!(args)
    options

  end
end

class DeviceInfo
  def initialize(name,community_auth)
    @name = name
    @community_auth = community_auth
  end

  def is_up?
    # For some strange reason, ruby cannot create ICMP packets w/o root
    # So lets check that the host is up AND ssh is listening
    Net::Ping::TCP.new(@name,80,2).ping?
  end

  def status_text
    "#{@name} is #{is_up?}"
  end

  def snmp_manager
    SNMP::Manager.new(:host => @name, :community => @community_auth)
  end

  def get_rtp_count
    rtp_interface = 0
    rtp_active_count = 0
    while rtp_interface <= 43
      begin
        rtp_status_result = snmp_manager.get_value("1.3.6.1.4.1.5003.9.10.1.4.1.1.1.#{rtp_interface}")
        if rtp_status_result == 1
          rtp_active_count += 1
        end
        rtp_interface += 1
      rescue SNMP::RequestTimeout
        rtp_interface = 44
      end
    end
    rtp_active_count
  end
end

class RTPStats
  def initialize(critical_input,warning_input,max_input)
    @critical_level = critical_input.to_i
    @warning_level = warning_input.to_i
    @maximum_level = max_input.to_i
  end

  def status_level(status_input)
    if status_input >= @critical_level
      2
    elsif status_input >= @warning_level
      1
    elsif status_input < @warning_level
      0
    else
      3
    end
  end

  def status_text(status_input)
    if status_input == 2
      "CRITICAL"
    elsif status_input == 1
      "WARNING"
    elsif status_input == 0
      "OK"
    else
      "UNKNOWN"
    end
  end

  def print_rtp_stats(input_devices)
    # should print out "'deviceN'=9;80;87;;92' "
    input_devices.each do |key, value|
      "'#{key}'=#{value};#{@warning_level};#{@critical_level};;#{@maximum_level} "
    end
  end
end

unless SNMP::MIB.import_supported? then
  puts "libsmi package required; yum install libsmi"
  exit
end

options = GetTheOptions.parse(ARGV)
rtp_stats = RTPStats.new(options.critical,options.warning,options.maximum)
another_fucking_variable = Hash.new

total_active_connections = 0

options.device_list.each do |item|
  device = DeviceInfo.new(item,options.community)
  puts device.status_text
  if device.is_up? then
    current_rtp_session_count = device.get_rtp_count
    puts "#{item} count: #{current_rtp_session_count}"
    another_fucking_variable[item] = current_rtp_session_count
  else
    puts "#{item} down, no SNMP manager created"
  end
  total_active_connections += current_rtp_session_count
  current_rtp_session_count = 0
end
# We need it to print it in the format like this:
# OK Active Channels: 14 |'device1'=0;80;87;;92 'device2'=10;80;87;;92 'deviceN'=4;80;87;;92
puts "#{rtp_stats.status_text(options.exit_status)} Active Channels: #{total_active_connections} | #{rtp_stats.print_rtp_stats(another_fucking_variable)}"
options.exit_status = rtp_stats.status_level(total_active_connections)
puts rtp_stats.status_text(options.exit_status)
